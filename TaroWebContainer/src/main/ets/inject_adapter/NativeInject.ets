/*
 * Copyright (c) 2022-2023 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import uri from '@ohos.uri';
import window from '@ohos.window';
import common from '@ohos.app.ability.common';
import { BusinessError } from '@ohos.base';
import Want from '@ohos.app.ability.Want';
import bundleManager from '@ohos.bundle.bundleManager';
import fs from '@ohos.file.fs';

import {
  CapsuleController,
  ErrorMsg,
  InnerInjectObj,
  MenuButtonOptions,
  PermissionInfo,
  RequestSubscribeMessageOptions,
  SaveDataUrlOptions,
  SubscribeMessageOptions,
  SubscriptionsSetting,
  ChooseMediaOptions,
  ExitMiniProgramOptions,
  SettingOptions,
  NavigationStyle,
  ChooseMediumOptions,
  NativeDataChangeListener
} from '../interfaces/InjectObject';
import {
  getBundleUsedPermission,
  getBundleUserPermissions,
  getBundleWxScopeList,
  openPermissionsInSystemSettings,
} from '../utils/PermissionMapScopeUtil';
import {
  addNotificationManagerSlot,
  cancelMessage,
  CancelMessageOptions,
  enableNotification,
  getMassageList,
  NotificationBasicContent,
  NotificationContent,
  NotificationRequest,
  sendMessage,
  SendMessageOptions
} from '../utils/SubscribeMessageUtil';
import { NavigationBarData } from '../components/NavigationBar';
import { setSystemBarProperties } from '../utils/WindowUtil';
import { wbLogger } from '../utils/Logger';
import { switchHapSandBoxToInternal, switchInternalToHapSandBox } from '../utils/InternalPath';
import { LocalUpdateManagerInstance } from '../update/LocalUpdateManager';
import util from '@ohos.util';
import { selectMediaAssets } from '../utils/MediaUtil';
import { selectMediumAssets } from '../utils/MediumUtil';
import { MediaItemData, ChooseAlbumResult, chooseAlbumOptions } from '../interfaces/Media';
import { NativeCacheManager } from './NativeCacheManager';


const NATIVE_TAG = 'NativeInject';

/**
 * Native注入类，实现一些跟壳工程比较紧密关联的Taro API
 */

export class NativeInject {
  // 用于更新控制导航栏
  private navigationBarData: NavigationBarData;
  // 系统状态栏高度，包含avoid区域高度
  private systemBarHeight: number;
  // 应用宽度
  private windowWidth: number;
  // 权限信息
  private permissionInfo: bundleManager.ReqPermissionDetail[];
  // 胶囊的尺寸
  private capsuleOptions: MenuButtonOptions;
  // 胶囊显示控制
  private capsuleController: CapsuleController;
  private chooseAlbumCallback?: (options: chooseAlbumOptions, mediaItems: MediaItemData[]) => Promise<ChooseAlbumResult>;
  private nativeCacheManager: NativeCacheManager;

  constructor(navigationBarData: NavigationBarData, capsuleOptions: MenuButtonOptions, capsuleController: CapsuleController, nativeCacheManager: NativeCacheManager) {
    this.navigationBarData = navigationBarData;
    this.systemBarHeight = 0;
    this.windowWidth = 0;
    this.permissionInfo = [];
    this.capsuleOptions = capsuleOptions
    this.capsuleController = capsuleController
    this.nativeCacheManager = nativeCacheManager
  }

  private setStatusBarFrontColor(barFrontColor: string) {
    const context = getContext(this) as common.UIAbilityContext;
    window.getLastWindow(context).then((windowClass) => {
      setSystemBarProperties(windowClass, barFrontColor);
    });
  }

  public setChooseAlbumCallback(cb: (options: chooseAlbumOptions, mediaItems: MediaItemData[]) => Promise<ChooseAlbumResult>) {
    this.chooseAlbumCallback = cb;
  }

  public setSystemBarHeight(systemBarHeight: number) {
    this.systemBarHeight = systemBarHeight;
  }

  public setWindowWidth(windowWidth: number) {
    this.windowWidth = windowWidth;
  }

  public setPermissionInfo(permissionInfo: bundleManager.ReqPermissionDetail[]) {
    this.permissionInfo = permissionInfo;
  }

  public buildInjectObj(context: common.UIAbilityContext): InnerInjectObj {
    return {
      registerNativeListener:(listener: NativeDataChangeListener | null)=>{
        this.nativeCacheManager.registerNativeListener(listener)
      },

      copyFileToSandboxCache: (src: string) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$copyFileToSandboxCache`)
        const context = getContext() as common.UIAbilityContext;
        const fileName = src.substring(src.lastIndexOf('/') + 1);
        const sandboxPath = `${context.cacheDir}/${Date.now()}_${fileName}`;
        const fd = fs.openSync(src, fs.OpenMode.READ_ONLY).fd;
        fs.copyFileSync(fd, sandboxPath);
        return { internalCachePath: switchHapSandBoxToInternal(sandboxPath) }
      },
      setNavigationBarColor: (options) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$setNavigationBarColor`)
        wbLogger.info(NATIVE_TAG, `setNavigationBarColor: ${JSON.stringify(options || {})}`)
        this.navigationBarData.barColor = options.backgroundColor ?? this.navigationBarData.barColor;
        this.navigationBarData.barFrontColor = options.frontColor ?? this.navigationBarData.barFrontColor;
        if (options.animation) {
          this.navigationBarData.animationDuration = options.animation.duration ?? 0;
          const timingFuncMap = new Map([
            ['linear', Curve.Linear],
            ['easeIn', Curve.EaseIn],
            ['easeOut', Curve.EaseOut],
            ['easeInOut', Curve.EaseInOut],
          ])
          if (options.timingFunc && timingFuncMap.has(options.timingFunc)) {
            this.navigationBarData.animationCurve = Number(timingFuncMap.get(options.timingFunc) ?? Curve.Linear);
          }
        }
        this.setStatusBarFrontColor(this.navigationBarData.barFrontColor);
      },
      showNavigationBarLoading: () => {
        wbLogger.debug('JsBridgeNative', `NativeApi$showNavigationBarLoading`)
        this.navigationBarData.loading = true;
      },
      hideNavigationBarLoading: () => {
        wbLogger.debug('JsBridgeNative', `NativeApi$hideNavigationBarLoading`)
        this.navigationBarData.loading = false;
      },
      getMenuButtonBoundingClientRect: () => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getMenuButtonBoundingClientRect`)
        return {
          left: this.windowWidth - this.capsuleOptions.marginRight - this.capsuleOptions.width,
          right: this.windowWidth - this.capsuleOptions.marginRight,
          top: this.systemBarHeight,
          bottom: this.systemBarHeight + this.capsuleOptions.height,
          width: this.capsuleOptions.width,
          height: this.capsuleOptions.height,
        }
      },
      navigateToMiniProgram: async (options) => {
        // options.path 格式:
        // - EntryAbility:///pages/api/framework/index?paramA=good
        // - /pages/api/framework/index?paramA=good
        wbLogger.debug('JsBridgeNative', `NativeApi$navigateToMiniProgram`)
        wbLogger.info(NATIVE_TAG, 'navigateToMiniProgram options:' + JSON.stringify(options));
        const entryAbility = 'EntryAbility';
        let abilityName = entryAbility;
        let path = '';
        let query = '';
        if (options.path) {
          const targetUri: string = options.path.startsWith('/') ? `${entryAbility}://${options.path}` : options.path;
          const uriInfo = new uri.URI(targetUri);
          abilityName = uriInfo.scheme;
          path = uriInfo.path;
          query = (!uriInfo.query || uriInfo.query === 'null') ? '' : uriInfo.query;
        }
        const wantInfo: Want = {
          deviceId: '',
          bundleName: options.appId,
          abilityName,
          parameters: {
            extraData: options.extraData || {},
            path,
            query,
          },
        };
        wbLogger.debug(NATIVE_TAG, `navigateToMiniProgram: ${JSON.stringify(wantInfo)}`);
        try {
          const context = getContext(this) as common.UIAbilityContext;
          context.startAbility(wantInfo).then(() => {
            options.success({ errMsg: '' });
          }).catch(() => {
            options.fail({ errMsg: 'invalid appid or path scheme' } as ErrorMsg);
          })
        } catch (paramError) {
          wbLogger.warn(NATIVE_TAG, `navigateToMiniProgram failed: ${JSON.stringify(paramError)}`);
          options.fail({
            errMsg: `code: ${(paramError as BusinessError).code}, message ${(paramError as BusinessError).message}`
          } as ErrorMsg
          );
        }
      },
      setNavigationStyle: (navigationStyle: NavigationStyle) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$setNavigationStyle`)
        this.navigationBarData.visible = navigationStyle.style !== 'custom';
        this.navigationBarData.barFrontColor = navigationStyle.textStyle === 'white' ? '#ffffff' : '#000000';
        this.navigationBarData.barColor = navigationStyle.backgroundColor;
        this.navigationBarData.animationDuration = 0;
        this.setStatusBarFrontColor(this.navigationBarData.barFrontColor);
      },
      openSetting: async (options: SettingOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$openSetting`)
        const apiName: string = 'openSetting';
        // 接口返回
        try {
          const curPermissions: Array<PermissionInfo> = getBundleUserPermissions(this.permissionInfo);
          const bundleScope = await getBundleWxScopeList(curPermissions);
          const bundleUsedScope = getBundleUsedPermission(bundleScope.allScope, bundleScope.bundleScope);
          // 打开应用的权限列表
          openPermissionsInSystemSettings();
          if (options.withSubscriptions) {
            let NotificationBasicContent: NotificationBasicContent = {
              title: '设置',
              text: '获取中',
              additionalText: "",
            }
            let NotificationContent: NotificationContent = {
              contentType: 'NOTIFICATION_CONTENT_BASIC_TEXT',
              normal: NotificationBasicContent
            }
            let notificationRequests: NotificationRequest = {
              id: 1222287986,
              slotType: 'OTHER_TYPES',
              content: NotificationContent,
              path: ''
            }
            let sendMessageOption: SendMessageOptions = {
              notificationRequest: notificationRequests
            }
            let subscriptionsSetting: SubscriptionsSetting = {
              mainSwitch: false,
              itemSettings: []
            }
            await sendMessage(sendMessageOption).then(async (res) => {
              let cancelMessageOptions: CancelMessageOptions = {
                id: 1222287986
              }
              await cancelMessage(cancelMessageOptions).then((res) => {
                subscriptionsSetting.mainSwitch = true
              }).catch((err: Error) => {
                subscriptionsSetting.mainSwitch = false
              })
            }).catch((err: Error) => {
              wbLogger.debug(NATIVE_TAG, 'requestSubscribeMessage %{public}s', JSON.stringify(err))
            })
            const subscribeCode = await getMassageList()
            subscriptionsSetting.itemSettings = subscribeCode.massageList
            options.success({
              authSetting: bundleUsedScope.allScope,
              subscriptionsSetting: subscriptionsSetting,
              errMsg: `${apiName}:ok`
            });
          }
          options.success({ authSetting: bundleUsedScope.allScope, errMsg: `${apiName}:ok` });
        } catch (paramError) {
          wbLogger.warn(NATIVE_TAG, `openSetting: ${JSON.stringify(paramError)}`);
          options.fail({
            errMsg: `${apiName}:fail error code: ${(paramError as BusinessError).code} ${(paramError as BusinessError).message}`
          } as ErrorMsg
          );
        }
        options.complete('openSetting: complete success')
      },
      getSetting: async (options: SettingOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getSetting`)
        const apiName: string = 'getSetting';
        // 接口返回
        try {
          const curPermissions: Array<PermissionInfo> = getBundleUserPermissions(this.permissionInfo);
          const bundleScope = await getBundleWxScopeList(curPermissions);
          const bundleUsedScope = getBundleUsedPermission(bundleScope.allScope, bundleScope.bundleScope);
          if (options.withSubscriptions) {
            let NotificationBasicContent: NotificationBasicContent = {
              title: '设置',
              text: '获取中',
              additionalText: "",
            }
            let NotificationContent: NotificationContent = {
              contentType: 'NOTIFICATION_CONTENT_BASIC_TEXT',
              normal: NotificationBasicContent
            }
            let notificationRequests: NotificationRequest = {
              id: 1222287986,
              slotType: 'OTHER_TYPES',
              content: NotificationContent,
              path: ''
            }
            let sendMessageOption: SendMessageOptions = {
              notificationRequest: notificationRequests
            }
            let subscriptionsSetting: SubscriptionsSetting = {
              mainSwitch: false,
              itemSettings: []
            }
            await sendMessage(sendMessageOption).then(async (res) => {
              let cancelMessageOptions: CancelMessageOptions = {
                id: 1222287986
              }
              await cancelMessage(cancelMessageOptions).then((res) => {
                subscriptionsSetting.mainSwitch = true
              }).catch((err: Error) => {
                subscriptionsSetting.mainSwitch = false
              })
            }).catch((err: Error) => {
              wbLogger.debug(NATIVE_TAG, 'requestSubscribeMessage %{public}s', JSON.stringify(err))
            })
            const subscribeCode = await getMassageList()
            subscriptionsSetting.itemSettings = subscribeCode.massageList
            options.success({
              authSetting: bundleUsedScope.allScope,
              subscriptionsSetting: subscriptionsSetting,
              errMsg: `${apiName}:ok`
            });
          }
          options.success({ authSetting: bundleUsedScope.allScope, errMsg: `${apiName}:ok` });
        } catch (paramError) {
          options.fail({
            errMsg: `${apiName}:fail error code: ${(paramError as BusinessError).code} ${(paramError as BusinessError).message}`
          } as ErrorMsg
          );
        }
        options.complete('getSetting: complete success')
      },
      applyUpdate: () => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getUpdateManager`)
        return LocalUpdateManagerInstance.applyUpdate();
      },
      onCheckForUpdate: (option: ESObject) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getUpdateManager`)
        return LocalUpdateManagerInstance.onCheckForUpdate(option);
      },
      onUpdateFailed: (option: ESObject) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getUpdateManager`)
        return LocalUpdateManagerInstance.onUpdateFailed(option);
      },
      onUpdateReady: (option: ESObject) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getUpdateManager`)
        return LocalUpdateManagerInstance.onUpdateReady(option);
      },
      requestSubscribeMessage: async (options: RequestSubscribeMessageOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$requestSubscribeMessage`)
        const apiName: string = 'requestSubscribeMessage';
        try {
          const enableCode = await enableNotification();
          if (enableCode.errMsg === 'success') {
            const addSlotCode = await addNotificationManagerSlot(options)
            wbLogger.debug(NATIVE_TAG, 'requestSubscribeMessage %{public}s', JSON.stringify(addSlotCode))
            if (addSlotCode.errMsg == 'success') {
              options.success({ errMsg: `${apiName}:ok` });
            } else {
              options.fail({ errMsg: `${apiName}:error` });
            }
          } else {
            options.fail({ errMsg: `EnableNotification fail` });
          }
        } catch (paramError) {
          let enableCode: SubscribeMessageOptions = {
            errCode: (paramError as BusinessError).code,
            errMsg: `${apiName}:fail error ${(paramError as BusinessError).message}`
          }
          options.fail({ errMsg: enableCode.errMsg });
        }
      },
      saveDataUrlToFile: (options: SaveDataUrlOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$saveDataUrlToFile`)
        try {
          let tmpFilePath = `internal://cache/${Date.now()}_${options.url.split('/').splice(-1, 1).toString()}`;
          const data = options.data.split(',');
          if (data.length !== 2) {
            options.fail({ errMsg: 'Invalid data' })
            return;
          }
          if (data[0].startsWith('data:text/html')) {
            tmpFilePath += '.html';
          }
          const cachePath = switchInternalToHapSandBox(options.filePath || tmpFilePath);
          const base64 = new util.Base64Helper();
          const buf = base64.decodeSync(data[1]);
          const file = fs.openSync(cachePath, fs.OpenMode.READ_WRITE | fs.OpenMode.CREATE);
          fs.write(file.fd, buf.buffer).then(() => {
            options.success({ tempFilePath: options.filePath || tmpFilePath });
          }).catch((err: BusinessError) => {
            options.fail({ errMsg: err.message });
          }).finally(() => {
            fs.closeSync(file.fd);
          })
        } catch (err) {
          options.fail({ errMsg: 'error' });
        }
      },
      setCapsuleState: (visible: boolean) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$setCapsuleState`)
        this.capsuleController.changeCapsuleState(visible);
      },
      getCapsuleState: () => {
        wbLogger.debug('JsBridgeNative', `NativeApi$getCapsuleState`)
        return { visible: this.capsuleController.getCapsuleState() }
      },
      chooseMediaAssets: (options: ChooseMediaOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$chooseMediaAssets`)
        selectMediaAssets(options, this.chooseAlbumCallback!)
      },
      chooseMediumAssets: (options: ChooseMediumOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$chooseMediumAssets`)
        selectMediumAssets(options)
      },
      exitMiniProgram: (options?: ExitMiniProgramOptions) => {
        wbLogger.debug('JsBridgeNative', `NativeApi$exitMiniProgram`)
        try {
          context.terminateSelf()
            .then(() => {
              options && options.success()
            })
            .catch((err: BusinessError) => {
              options && options.fail()
            });
        } catch (err) {
          options && options.fail()
        }
        options && options.complete()
      }
    };
  }
}
